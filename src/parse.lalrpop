// Copyright 2018 Ethan Pailes.
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

use regex_syntax;
use regex_syntax::ast::RepetitionRange;
use lalrpop_util::ParseError;
use ast::{Expr, ExprKind, Span, BOp, UOp, StatementKind, Statement};
use error;
use error::{InternalError, ErrorKind};
use lex;

grammar<'input>;

extern {
    type Location = usize;
    type Error = error::InternalError;

    enum lex::Token<'input> {
        "regex literal" => lex::Token::RegexLit(<String>),
        "raw regex literal" => lex::Token::RawRegexLit(<&'input str>),
        "int" => lex::Token::IntLit(<i64>),
        "float" => lex::Token::FloatLit(<f64>),
        "str" => lex::Token::StringLit(<String>),
        "true" => lex::Token::True,
        "false" => lex::Token::False,
        "identifier" => lex::Token::Id(<&'input str>),

        "(" => lex::Token::OpenParen,
        ")" => lex::Token::CloseParen,

        "[" => lex::Token::OpenBracket,
        "]" => lex::Token::CloseBracket,

        "{" => lex::Token::OpenCurly,
        "}" => lex::Token::CloseCurly,
        "}?" => lex::Token::LazyCloseCurly,

        "*" => lex::Token::Star,
        "*?" => lex::Token::LazyStar,

        "+" => lex::Token::Plus,
        "+?" => lex::Token::LazyPlus,

        "," => lex::Token::Comma,
        ";" => lex::Token::Semi,
        "|" => lex::Token::Pipe,
        "." => lex::Token::Dot,
        "=" => lex::Token::Equals,
        "?" => lex::Token::Question,
        "??" => lex::Token::LazyQuestion,

        "==" => lex::Token::DoubleEq,
        "!=" => lex::Token::Ne,
        "<" => lex::Token::Lt,
        ">" => lex::Token::Gt,
        "<=" => lex::Token::Le,
        ">=" => lex::Token::Ge,
        "&&" => lex::Token::And,
        "||" => lex::Token::Or,
        "!" => lex::Token::Bang,
        ":" => lex::Token::Colon,

        "<+>" => lex::Token::Add,
        "</>" => lex::Token::Div,
        "<*>" => lex::Token::Times,
        "-" => lex::Token::Minus,
        "%" => lex::Token::Percent,

        "as" => lex::Token::As,
        "cap" => lex::Token::Cap,
        "let" => lex::Token::Let,
        "if" => lex::Token::If,
        "else" => lex::Token::Else,
        "in" => lex::Token::In,
        "for" => lex::Token::For,
        "break" => lex::Token::Break,
        "continue" => lex::Token::Continue,
        "while" => lex::Token::While,
        "loop" => lex::Token::Loop,
    }
}

pub BlockBody: Expr = {
    <l: @L> <s: (<Statement>)*> <e: Expr0> <r: @R> => {
        Expr {
            kind: ExprKind::Block(s, e),
            span: Span { start: l, end: r }
        }
    }
};

//////////////////////////////////////////////////////////////////////////
//                                                                      //
//                            Expressions                               //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

Expr0: Box<Expr> = {
    <l: @L> <e:ExprKind0> <r: @R> =>
        Box::new(Expr::new(e, Span { start: l, end: r })),
    <l: @L> "{" <b:BlockBody> "}" <r: @R> =>
        Box::new(Expr::new(b.kind, Span { start: l, end: r })),
};
ExprKind0: ExprKind = {
    <e1:Expr0> "." <e2:Expr1> => ExprKind::BinOp(e1, BOp::Concat, e2),
    <e1:Expr0> "|" <e2:Expr1> => ExprKind::BinOp(e1, BOp::Alt, e2),

    <e1:Expr0> "==" <e2:Expr1> => ExprKind::BinOp(e1, BOp::Equals, e2),
    <e1:Expr0> "!=" <e2:Expr1> => ExprKind::BinOp(e1, BOp::Ne, e2),
    <e1:Expr0> "<" <e2:Expr1> => ExprKind::BinOp(e1, BOp::Lt, e2),
    <e1:Expr0> ">" <e2:Expr1> => ExprKind::BinOp(e1, BOp::Gt, e2),
    <e1:Expr0> "<=" <e2:Expr1> => ExprKind::BinOp(e1, BOp::Le, e2),
    <e1:Expr0> ">=" <e2:Expr1> => ExprKind::BinOp(e1, BOp::Ge, e2),
    <e1:Expr0> "&&" <e2:Expr1> => ExprKind::BinOp(e1, BOp::And, e2),
    <e1:Expr0> "||" <e2:Expr1> => ExprKind::BinOp(e1, BOp::Or, e2),
    <e1:Expr0> "in" <e2:Expr1> => ExprKind::BinOp(e1, BOp::In, e2),

    <e1:Expr0> "[" <e2:Expr0> "]" => ExprKind::Index(e1, e2),
    <e1:Expr0> "[" <e2:Expr0> ":" <e3:Expr0> "]" =>
        ExprKind::IndexSlice {
            collection: e1,
            start: Some(e2),
            end: Some(e3),
        },

    <e1:Expr0> "[" <e2:Expr0> ":" "]" =>
        ExprKind::IndexSlice {
            collection: e1,
            start: Some(e2),
            end: None,
        },

    <e1:Expr0> "[" ":" <e2:Expr0> "]" =>
        ExprKind::IndexSlice {
            collection: e1,
            start: None,
            end: Some(e2),
        },

    <e1:Expr0> "[" ":" "]" =>
        ExprKind::IndexSlice {
            collection: e1,
            start: None,
            end: None,
        },

    ExprKind1
};

Expr1: Box<Expr> = {
    <l: @L> <e:ExprKind1> <r: @R> =>
        Box::new(Expr::new(e, Span { start: l, end: r }))
};
ExprKind1: ExprKind = {
    "cap" <e:Expr2> "as" <name:"identifier"> =>
        ExprKind::Capture(e, Some(name.to_string())),

    ExprKind2
};

Expr2: Box<Expr> = {
    <l: @L> <e:ExprKind2> <r: @R> =>
        Box::new(Expr::new(e, Span { start: l, end: r }))
};
ExprKind2: ExprKind = {
    "cap" <e:Expr2> => ExprKind::Capture(e, None),

    ExprKind3
};

Expr3: Box<Expr> = {
    <l: @L> <e:ExprKind3> <r: @R> =>
        Box::new(Expr::new(e, Span { start: l, end: r }))
};
ExprKind3: ExprKind = {
    // TODO(ethan): remove if it isn't useful

    ExprKind4,
};

Expr4: Box<Expr> = {
    <l: @L> <e:ExprKind4> <r: @R> =>
        Box::new(Expr::new(e, Span { start: l, end: r }))
};
ExprKind4: ExprKind = {

    ExprKind5,
};

Expr5: Box<Expr> = {
    <l: @L> <e:ExprKind5> <r: @R> =>
        Box::new(Expr::new(e, Span { start: l, end: r }))
};
ExprKind5: ExprKind = {
    //
    // Arith operators
    //
    "!" <e:Expr6> => ExprKind::UnaryOp(UOp::Not, e),
    "-" <e:Expr6> => ExprKind::UnaryOp(UOp::Neg, e),

    <e1:Expr5> "<+>" <e2:Expr6> => ExprKind::BinOp(e1, BOp::Plus, e2),
    <e1:Expr5> "<*>" <e2:Expr6> => ExprKind::BinOp(e1, BOp::Times, e2),
    <e1:Expr5> "</>" <e2:Expr6> => ExprKind::BinOp(e1, BOp::Div, e2),
    <e1:Expr5> "-" <e2:Expr6> => ExprKind::BinOp(e1, BOp::Minus, e2),
    <e1:Expr5> "%" <e2:Expr6> => ExprKind::BinOp(e1, BOp::Mod, e2),

    //
    // Regex operators
    //
    <e:Expr5> "*" => ExprKind::UnaryOp(UOp::RepeatZeroOrMore(true), e),
    <e:Expr5> "*?" => ExprKind::UnaryOp(UOp::RepeatZeroOrMore(false), e),
    <e:Expr5> "+" => ExprKind::UnaryOp(UOp::RepeatOneOrMore(true), e),
    <e:Expr5> "+?" => ExprKind::UnaryOp(UOp::RepeatOneOrMore(false), e),
    <e:Expr5> "?" => ExprKind::UnaryOp(UOp::RepeatZeroOrOne(true), e),
    <e:Expr5> "??" => ExprKind::UnaryOp(UOp::RepeatZeroOrOne(false), e),

    <e:Expr5> "{" <i:"int"> "}" =>
        ExprKind::UnaryOp(UOp::RepeatRange(
            false, RepetitionRange::Exactly(i as u32)), e),
    <e:Expr5> "{" <i:"int"> "," "}" =>
        ExprKind::UnaryOp(UOp::RepeatRange(
            false, RepetitionRange::AtLeast(i as u32)), e),
    <e:Expr5> "{" <i1:"int"> "," <i2:"int"> "}" =>
        ExprKind::UnaryOp(UOp::RepeatRange(
            false, RepetitionRange::Bounded(i1 as u32, i2 as u32)), e),

    <e:Expr5> "{" <i:"int"> "}?" =>
        ExprKind::UnaryOp(UOp::RepeatRange(
            true, RepetitionRange::Exactly(i as u32)), e),
    <e:Expr5> "{" <i:"int"> "," "}?" =>
        ExprKind::UnaryOp(UOp::RepeatRange(
            true, RepetitionRange::AtLeast(i as u32)), e),
    <e:Expr5> "{" <i1:"int"> "," <i2:"int"> "}?" =>
        ExprKind::UnaryOp(UOp::RepeatRange(
            true, RepetitionRange::Bounded(i1 as u32, i2 as u32)), e),

    ExprKind6,
};

Expr6: Box<Expr> = {
    <l: @L> <e:ExprKind6> <r: @R> =>
        Box::new(Expr::new(e, Span { start: l, end: r })),
};
ExprKind6: ExprKind = {
    <r:RegexLiteral> => ExprKind::RegexLiteral(r),
    <int:"int"> => ExprKind::IntLiteral(int),
    <var:"identifier"> => ExprKind::Var(var.to_string()),
    <float:"float"> => ExprKind::FloatLiteral(float),
    <str:"str"> => ExprKind::StringLiteral(str),
    "true" => ExprKind::BoolLiteral(true),
    "false" => ExprKind::BoolLiteral(false),
    "{" <entries: Comma<DictEntry>> "}" => ExprKind::DictLiteral(entries),
    "(" <entries: Comma1<Expr0>> ")" => ExprKind::TupleLiteral(entries),
    "[" <entries: Comma<Expr0>> "]" => ExprKind::VectorLiteral(entries),


    "if" "(" <cond: Expr0> ")" "{"
        <true_branch: Expr0>
    <middle_branches: ("}" "else" "if" "(" Expr0 ")" "{" Expr0)*>
    "}" "else" "{"
        <false_branch: Expr0>
    "}"
    => {
        let mut false_branch = false_branch;
        for branch in middle_branches.into_iter().rev() {
            let cond = branch.4;
            let branch = branch.7;
            let l = cond.span.start;
            let r = branch.span.end;

            false_branch = Box::new(Expr::new(
                ExprKind::If {
                    condition: cond,
                    true_branch: branch,
                    false_branch: false_branch,
                },
                Span { start: l, end: r }));
        }

        ExprKind::If {
            condition: cond,
            true_branch: true_branch,
            false_branch: false_branch,
        }
    },

    "(" <ExprKind0> ")",
};

LValue: Box<Expr> = {
    <l: @L> <e:LValueKind> <r: @R> =>
        Box::new(Expr::new(e, Span { start: l, end: r })),
};
LValueKind: ExprKind = {
    <var:"identifier"> => ExprKind::Var(var.to_string()),
    <e1:Expr0> "[" <e2:Expr0> "]" => ExprKind::Index(e1, e2),
};

DictEntry: (Box<Expr>, Box<Expr>) =
    <key: Expr0> ":" <value: Expr0> => (key, value);

RegexLiteral: Box<regex_syntax::ast::Ast> = {

    // raw regex literals
    <l: @L> <s:"raw regex literal"> <r: @R> =>? {
        use regex_syntax::ast::parse::Parser;
        match Parser::new().parse(&regex_syntax::escape(s)) {
            Ok(re) => Ok(Box::new(re)),
            Err(err) => Err(ParseError::User {
                error: InternalError::new(
                    ErrorKind::RegexError {
                        re: String::from(s),
                        err: format!("{}", err),
                    },
                    Span { start: l, end: r }),
            }),
        }
    },

    // regex literals
    <l: @L> <s:"regex literal"> <r: @R> =>? {
        use regex_syntax::ast::parse::Parser;
        match Parser::new().parse(&s) {
            Ok(re) => Ok(Box::new(re)),
            Err(err) => Err(ParseError::User {
                error: InternalError::new(
                    ErrorKind::RegexError {
                        re: s,
                        err: format!("{}", err),
                    },
                    Span { start: l, end: r }),
            }),
        }
    },
};

//////////////////////////////////////////////////////////////////////////
//                                                                      //
//                            Statements                                //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

Statement: Statement = {
    <l: @L> <s:StatementKind> <r: @R> =>
        Statement::new(s, Span { start: l, end: r })
};
StatementKind: StatementKind = {
    "if" "(" <cond: Expr0> ")" "{"
        <true_branch: Statement+>
    "}" =>
        StatementKind::IfTrue {
            condition: cond,
            true_branch: true_branch,
        },

    "if" "(" <cond: Expr0> ")" "{"
        <true_branch: Statement+>
    <middle_branches: ("}" "else" "if" "(" Expr0 ")" "{" Statement+)*>
    "}" "else" "{"
        <false_branch: Statement+>
    "}"
    => {
        let mut false_branch = false_branch;
        for branch in middle_branches.into_iter().rev() {
            let cond = branch.4;
            let block = branch.7;
            let l = cond.span.start;
            let r = block[block.len() - 1].span.end;

            false_branch = vec![Statement::new(
                StatementKind::IfElse {
                    condition: cond,
                    true_branch: block,
                    false_branch: false_branch,
                },
                Span { start: l, end: r })];
        }

        StatementKind::IfElse {
            condition: cond,
            true_branch: true_branch,
            false_branch: false_branch,
        }
    },

    "for" "(" <var:"identifier"> "in" <collection:Expr0> ")" "{"
        <body: Statement+>
    "}" => {
        StatementKind::For {
            variable: var.to_string(),
            collection: collection,
            body: body,
        }
    },

    "while" "(" <condition: Expr0> ")" "{"
        // we do allow empty while body, cause that can sometimes be
        // useful for some hackery
        <body: Statement*>
    "}" => {
        StatementKind::While {
            condition: condition,
            body: body,
        }
    },

    <l: @L> "loop" <r: @R> "{"
        // we do allow empty while body, cause that can sometimes be
        // useful for some hackery
        <body: Statement*>
    "}" => {
        StatementKind::While {
            condition: Box::new(Expr::new(
                ExprKind::BoolLiteral(true),
                Span { start: l, end: r }
                )),
            body: body,
        }
    },

    "let" <id:"identifier"> "=" <e:Expr0> ";" => {
        StatementKind::LetBinding(String::from(id), e)
    },
    <lv:LValue> "=" <e:Expr0> ";" => {
        StatementKind::Assign(lv, e)
    },
    <e:Expr0> ";" => StatementKind::Expr(e),
    "break" ";" => StatementKind::Break,
    "continue" ";" => StatementKind::Continue,
};

//////////////////////////////////////////////////////////////////////////
//                                                                      //
//                            Utilities                                 //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

Comma<Rule>: Vec<Rule> =
    <rules: (<Rule> ",")*> <last: Rule?> => {
        let mut rules = rules;
        rules.extend(last);
        rules
    };

Comma1<Rule>: Vec<Rule> =
    <rules: (<Rule> ",")+> <last: Rule?> => {
        let mut rules = rules;
        rules.extend(last);
        rules
    };
