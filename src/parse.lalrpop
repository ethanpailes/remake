use std::str::FromStr;
use regex_syntax;
use regex_syntax::ast::RepetitionRange;
use lalrpop_util::ParseError;
use ast::{Expr, ExprKind, Span, BOp, UOp};
use error;
use error::{InternalError, ErrorKind};

grammar;

// TODO: the syntax should look like dynamic rust
// TODO: capture syntax
//          - unnamed capture: cap <expr>
//          - named capture: cap <expr> as <id>

extern {
    type Error = error::InternalError;
}

pub Expr: Box<Expr> = {
    <l: @L> <e:ExprKind0> <r: @R> =>
        Box::new(Expr::new(e, Span { start: l, end: r }))
};
ExprKind0: ExprKind = {
    // "cap" <e:Expr> "as" <name:Id> => ExprKind::Capture(e, Some(name)),
    <e:CapExpr> "as" <name:Id> => ExprKind::Capture(e, Some(name)),

    ExprKind1
};

Expr1: Box<Expr> = {
    <l: @L> <e:ExprKind1> <r: @R> =>
        Box::new(Expr::new(e, Span { start: l, end: r }))
};
ExprKind1: ExprKind = {
    // "cap" <e:Expr1> => ExprKind::Capture(e, None),
    <CapExpr> => ExprKind::Capture(<>, None),

    ExprKind2
};

CapExpr: Box<Expr> = {
    "cap" <e:Expr1> => e
};

Expr2: Box<Expr> = {
    <l: @L> <e:ExprKind2> <r: @R> =>
        Box::new(Expr::new(e, Span { start: l, end: r }))
};
ExprKind2: ExprKind = {
    <e1:Expr2> "." <e2:Expr3> => ExprKind::BinOp(e1, BOp::Concat, e2),
    <e1:Expr2> "|" <e2:Expr3> => ExprKind::BinOp(e1, BOp::Alt, e2),
    ExprKind3
};

Expr3: Box<Expr> = {
    <l: @L> <e:ExprKind3> <r: @R> =>
        Box::new(Expr::new(e, Span { start: l, end: r }))
};
ExprKind3: ExprKind = {
    <e:Expr3> "*" => ExprKind::UnaryOp(UOp::RepeatZeroOrMore(true), e),
    <e:Expr3> "*?" => ExprKind::UnaryOp(UOp::RepeatZeroOrMore(false), e),
    <e:Expr3> "+" => ExprKind::UnaryOp(UOp::RepeatOneOrMore(true), e),
    <e:Expr3> "+?" => ExprKind::UnaryOp(UOp::RepeatOneOrMore(false), e),
    <e:Expr3> "?" => ExprKind::UnaryOp(UOp::RepeatZeroOrOne(true), e),
    <e:Expr3> "??" => ExprKind::UnaryOp(UOp::RepeatZeroOrOne(false), e),

    <e:Expr3> "{" <i:Int32> "}" =>
        ExprKind::UnaryOp(UOp::RepeatRange(
            false, RepetitionRange::Exactly(i)), e),
    <e:Expr3> "{" <i:Int32> "," "}" =>
        ExprKind::UnaryOp(UOp::RepeatRange(
            false, RepetitionRange::AtLeast(i)), e),
    <e:Expr3> "{" <i1:Int32> "," <i2:Int32> "}" =>
        ExprKind::UnaryOp(UOp::RepeatRange(
            false, RepetitionRange::Bounded(i1, i2)), e),

    <e:Expr3> "{" <i:Int32> "}?" =>
        ExprKind::UnaryOp(UOp::RepeatRange(
            true, RepetitionRange::Exactly(i)), e),
    <e:Expr3> "{" <i:Int32> "," "}?" =>
        ExprKind::UnaryOp(UOp::RepeatRange(
            true, RepetitionRange::AtLeast(i)), e),
    <e:Expr3> "{" <i1:Int32> "," <i2:Int32> "}?" =>
        ExprKind::UnaryOp(UOp::RepeatRange(
            true, RepetitionRange::Bounded(i1, i2)), e),

    ExprKind4,
};

Expr4: Box<Expr> = {
    <l: @L> <e:ExprKind4> <r: @R> =>
        Box::new(Expr::new(e, Span { start: l, end: r }))
};
ExprKind4: ExprKind = {
    <r:RegexLiteral> => ExprKind::RegexLiteral(r),
    "(" <ExprKind0> ")",
};

Int32: u32 = {
    // TODO(ethan): bubble the overflow up as an error.
    r"[0-9]+" => u32::from_str(<>).unwrap()
};

Id: String = {
    r"[a-zA-Z][a-zA-Z0-9_]*" => String::from(<>)
};

RegexLiteral: Box<regex_syntax::ast::Ast> = {
    // raw literals
    <l: @L> <s:r"'[^']+'"> <r: @R> =>? {
        use regex_syntax::ast::parse::Parser;
        match Parser::new().parse(&regex_syntax::escape(&s[1..(s.len() - 1)])) {
            Ok(re) => Ok(Box::new(re)),
            Err(err) => Err(ParseError::User {
                error: InternalError::new(
                    ErrorKind::RegexError {
                        re: String::from(s),
                        err: format!("{}", err),
                    },
                    Span { start: l, end: r }),
            }),
        }
    },

    // regex literals
    <l: @L> <s:r"/[^/]+/"> <r: @R> =>? {
        use regex_syntax::ast::parse::Parser;
        match Parser::new().parse(&s[1..(s.len() - 1)]) {
            Ok(re) => Ok(Box::new(re)),
            Err(err) => Err(ParseError::User {
                error: InternalError::new(
                    ErrorKind::RegexError {
                        re: String::from(s),
                        err: format!("{}", err),
                    },
                    Span { start: l, end: r }),
            }),
        }
    },
};
