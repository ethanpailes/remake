// Copyright 2018 Ethan Pailes.
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

use regex_syntax;
use regex_syntax::ast::RepetitionRange;
use lalrpop_util::ParseError;
use ast::{Expr, ExprKind, Span, BOp, UOp, StatementKind, Statement};
use error;
use error::{InternalError, ErrorKind};
use lex;

grammar<'input>;

extern {
    type Location = usize;
    type Error = error::InternalError;

    enum lex::Token<'input> {
        "regex literal" => lex::Token::RegexLit(<String>),
        "raw regex literal" => lex::Token::RawRegexLit(<&'input str>),
        "int" => lex::Token::IntLit(<i64>),
        "float" => lex::Token::FloatLit(<f64>),
        "str" => lex::Token::StringLit(<String>),
        "true" => lex::Token::True,
        "false" => lex::Token::False,
        "identifier" => lex::Token::Id(<&'input str>),

        "(" => lex::Token::OpenParen,
        ")" => lex::Token::CloseParen,

        "{" => lex::Token::OpenCurly,
        "}" => lex::Token::CloseCurly,
        "}?" => lex::Token::LazyCloseCurly,

        "*" => lex::Token::Star,
        "*?" => lex::Token::LazyStar,

        "+" => lex::Token::Plus,
        "+?" => lex::Token::LazyPlus,

        "," => lex::Token::Comma,
        ";" => lex::Token::Semi,
        "|" => lex::Token::Pipe,
        "." => lex::Token::Dot,
        "=" => lex::Token::Equals,
        "?" => lex::Token::Question,
        "??" => lex::Token::LazyQuestion,

        "==" => lex::Token::DoubleEq,
        "!=" => lex::Token::Ne,
        "<" => lex::Token::Lt,
        ">" => lex::Token::Gt,
        "<=" => lex::Token::Le,
        ">=" => lex::Token::Ge,
        "&&" => lex::Token::And,
        "||" => lex::Token::Or,
        "!" => lex::Token::Bang,

        "as" => lex::Token::As,
        "cap" => lex::Token::Cap,
        "let" => lex::Token::Let,
    }
}

pub BlockBody: Expr = {
    <l: @L> <s: (<Statement>)*> <e: Expr0> <r: @R> => {
        Expr {
            kind: ExprKind::Block(s, e),
            span: Span { start: l, end: r }
        }
    }
};

//////////////////////////////////////////////////////////////////////////
//                                                                      //
//                            Expressions                               //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

Expr0: Box<Expr> = {
    <l: @L> <e:ExprKind0> <r: @R> =>
        Box::new(Expr::new(e, Span { start: l, end: r })),
    <l: @L> "{" <b:BlockBody> "}" <r: @R> =>
        Box::new(Expr::new(b.kind, Span { start: l, end: r })),
};
ExprKind0: ExprKind = {
    <e1:Expr0> "." <e2:Expr1> => ExprKind::BinOp(e1, BOp::Concat, e2),
    <e1:Expr0> "|" <e2:Expr1> => ExprKind::BinOp(e1, BOp::Alt, e2),

    <e1:Expr0> "==" <e2:Expr1> => ExprKind::BinOp(e1, BOp::Equals, e2),
    <e1:Expr0> "!=" <e2:Expr1> => ExprKind::BinOp(e1, BOp::Ne, e2),
    <e1:Expr0> "<" <e2:Expr1> => ExprKind::BinOp(e1, BOp::Lt, e2),
    <e1:Expr0> ">" <e2:Expr1> => ExprKind::BinOp(e1, BOp::Gt, e2),
    <e1:Expr0> "<=" <e2:Expr1> => ExprKind::BinOp(e1, BOp::Le, e2),
    <e1:Expr0> ">=" <e2:Expr1> => ExprKind::BinOp(e1, BOp::Ge, e2),
    <e1:Expr0> "&&" <e2:Expr1> => ExprKind::BinOp(e1, BOp::And, e2),
    <e1:Expr0> "||" <e2:Expr1> => ExprKind::BinOp(e1, BOp::Or, e2),

    ExprKind1
};

Expr1: Box<Expr> = {
    <l: @L> <e:ExprKind1> <r: @R> =>
        Box::new(Expr::new(e, Span { start: l, end: r }))
};
ExprKind1: ExprKind = {
    <e:CapExpr> "as" <name:Id> => ExprKind::Capture(e, Some(name)),

    ExprKind2
};

Expr2: Box<Expr> = {
    <l: @L> <e:ExprKind2> <r: @R> =>
        Box::new(Expr::new(e, Span { start: l, end: r }))
};
ExprKind2: ExprKind = {
    <CapExpr> => ExprKind::Capture(<>, None),
    "!" <e:Expr2> => ExprKind::UnaryOp(UOp::Not, e),

    ExprKind3
};

CapExpr: Box<Expr> = {
    "cap" <e:Expr2> => e
};

Expr3: Box<Expr> = {
    <l: @L> <e:ExprKind3> <r: @R> =>
        Box::new(Expr::new(e, Span { start: l, end: r }))
};
ExprKind3: ExprKind = {
    <e:Expr3> "*" => ExprKind::UnaryOp(UOp::RepeatZeroOrMore(true), e),
    <e:Expr3> "*?" => ExprKind::UnaryOp(UOp::RepeatZeroOrMore(false), e),
    <e:Expr3> "+" => ExprKind::UnaryOp(UOp::RepeatOneOrMore(true), e),
    <e:Expr3> "+?" => ExprKind::UnaryOp(UOp::RepeatOneOrMore(false), e),
    <e:Expr3> "?" => ExprKind::UnaryOp(UOp::RepeatZeroOrOne(true), e),
    <e:Expr3> "??" => ExprKind::UnaryOp(UOp::RepeatZeroOrOne(false), e),

    <e:Expr3> "{" <i:"int"> "}" =>
        ExprKind::UnaryOp(UOp::RepeatRange(
            false, RepetitionRange::Exactly(i as u32)), e),
    <e:Expr3> "{" <i:"int"> "," "}" =>
        ExprKind::UnaryOp(UOp::RepeatRange(
            false, RepetitionRange::AtLeast(i as u32)), e),
    <e:Expr3> "{" <i1:"int"> "," <i2:"int"> "}" =>
        ExprKind::UnaryOp(UOp::RepeatRange(
            false, RepetitionRange::Bounded(i1 as u32, i2 as u32)), e),

    <e:Expr3> "{" <i:"int"> "}?" =>
        ExprKind::UnaryOp(UOp::RepeatRange(
            true, RepetitionRange::Exactly(i as u32)), e),
    <e:Expr3> "{" <i:"int"> "," "}?" =>
        ExprKind::UnaryOp(UOp::RepeatRange(
            true, RepetitionRange::AtLeast(i as u32)), e),
    <e:Expr3> "{" <i1:"int"> "," <i2:"int"> "}?" =>
        ExprKind::UnaryOp(UOp::RepeatRange(
            true, RepetitionRange::Bounded(i1 as u32, i2 as u32)), e),

    ExprKind4,
};

Expr4: Box<Expr> = {
    <l: @L> <e:ExprKind4> <r: @R> =>
        Box::new(Expr::new(e, Span { start: l, end: r }))
};
ExprKind4: ExprKind = {
    <r:RegexLiteral> => ExprKind::RegexLiteral(r),
    <var:Id> => ExprKind::Var(var),
    <int:"int"> => ExprKind::IntLiteral(int),
    <float:"float"> => ExprKind::FloatLiteral(float),
    <str:"str"> => ExprKind::StringLiteral(str),
    "true" => ExprKind::BoolLiteral(true),
    "false" => ExprKind::BoolLiteral(false),
    "(" <ExprKind0> ")",
};

Id: String = {
    "identifier" => String::from(<>)
};

RegexLiteral: Box<regex_syntax::ast::Ast> = {

    // raw regex literals
    <l: @L> <s:"raw regex literal"> <r: @R> =>? {
        use regex_syntax::ast::parse::Parser;
        match Parser::new().parse(&regex_syntax::escape(s)) {
            Ok(re) => Ok(Box::new(re)),
            Err(err) => Err(ParseError::User {
                error: InternalError::new(
                    ErrorKind::RegexError {
                        re: String::from(s),
                        err: format!("{}", err),
                    },
                    Span { start: l, end: r }),
            }),
        }
    },

    // regex literals
    <l: @L> <s:"regex literal"> <r: @R> =>? {
        use regex_syntax::ast::parse::Parser;
        match Parser::new().parse(&s) {
            Ok(re) => Ok(Box::new(re)),
            Err(err) => Err(ParseError::User {
                error: InternalError::new(
                    ErrorKind::RegexError {
                        re: s,
                        err: format!("{}", err),
                    },
                    Span { start: l, end: r }),
            }),
        }
    },
};

//////////////////////////////////////////////////////////////////////////
//                                                                      //
//                            Statements                                //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

Statement: Statement = {
    <l: @L> <s:StatementKind> ";" <r: @R> =>
        Statement::new(s, Span { start: l, end: r })
};
StatementKind: StatementKind = {
    "let" <id:Id> "=" <e:Expr0> => {
        StatementKind::LetBinding(String::from(id), e)
    }
};
