use regex_syntax;
use lalrpop_util::ParseError;
use ast::{Expr, ExprKind, Span};
use error;
use error::{Error, ErrorKind};

grammar;

extern {
    type Error = error::Error;
}

pub Expr: Box<Expr> = {
    <l: @L> <e:ExprKind> <r: @R> =>
        Box::new(Expr::new(e, Span { start: l, end: r }))
};

ExprKind: ExprKind = {
    <r:RegexLiteral> => ExprKind::RegexLiteral(r),
};

RegexLiteral: regex_syntax::ast::Ast = {
    // raw literals
    <l: @L> <s:r"'[^']+'"> <r: @R> =>? {
        use regex_syntax::ast::parse::Parser;
        match Parser::new().parse(&regex_syntax::escape(&s[1..(s.len() - 1)])) {
            Ok(re) => Ok(re),
            Err(err) => Err(ParseError::User {
                error: Error::new(
                    ErrorKind::RegexError {
                        re: String::from(s),
                        err: format!("{}", err),
                    },
                    Span { start: l, end: r }),
            }),
        }
    },

    // regex literals
    <l: @L> <s:r"/[^/]+/"> <r: @R> =>? {
        use regex_syntax::ast::parse::Parser;
        match Parser::new().parse(&s[1..(s.len() - 1)]) {
            Ok(re) => Ok(re),
            Err(err) => Err(ParseError::User {
                error: Error::new(
                    ErrorKind::RegexError {
                        re: String::from(s),
                        err: format!("{}", err),
                    },
                    Span { start: l, end: r }),
            }),
        }
    },
};
